;ID of student 1, __%
;ID of student 2, __%
;HAIFA CONVENTION
;NOTE!! FULL EXPLAINATION OF THE SOLUTION IS WRITTEN AT THE END OF THIS FILE

.ORIG X3000

    LD R6 STACK_ADDRESS

;--------- GET INPUT FROM USER --------
	JSR GetNum				;NO PARAMETERS NEEDED
	ADD R1,R0,#0			;R0 HOLDS THE RETURN VALUE
	ST R1,INNER_MATRIX_SIZE ;HOLDS  THE N FOR SIZE OF INNER MATRIX(MAZE)
	LD R2,Matrix_Address	;POINTS TO OUTER MATRIX 22X22
	
	LEA R0 GetMatrix_Mess
	PUTS					;PRINTS MESSAGE TO INPUT MTARIX
	LD R0 LINE_FEED 
	OUT
RETAKE:
	STR R2 R6 #-2			;POINTER TO OUTER MATRIX
	STR R1 R6 #-1			;LOADS (N)
	ADD R6 R6 #-2			;UPDATES R6
	JSR GetMatrix
	ADD R6 R6 #2			;CLOSES AFTER FINISHING GETMATRIX FUNC
	AND R0 R0 R0			;HOLDS RETURN VALUE FROMM GETMATRIX WHICH INDICATES IF LEGAL MATRIX OR NOT
	BRz SUCCES			
RETRY:						;ILLEGAL MATRIX ENTERED RETRY
	LEA R0 RETRY_MESS
	PUTS
	LD R0 LINE_FEED
	OUT
	BR RETAKE
SUCCES:
	LEA R0 SUCCES_MESS
	PUTS
	LD R0 LINE_FEED
	OUT

;----------- APPLY SOME UPDATES ON MATRIX -------------
;THIS UPDATES WILL HELPS AND SIMPLIFY THE SOLUTION TO THE BACKTRACKING FUNCTION

	LD R2 TwentyThreeValue		
	ADD R2 R2 #-1				;R2<-22
	ADD R1 R1 #-1				;HOLDS THE VALUE OF N-1
	
	STR R1 R6 #-2			
	STR R2 R6 #-1				;LOADS PARAMTERS FOR MUL FUNCTION TO DO R1 * R2 
	ADD R6 R6 #-2
	JSR Mul						;R0 HOLDS 22 * N-1
	ADD R6 R6 #2				

	ST R0,GO_TO_LAST_CELL		;TO NAVIGATE IN INNER MATRIX, THIS WILL TAKE US TO (N-1,N-1) <-> TO CHEESE!
	ADD R1 R1 #1				;RETURNS TO HOLD N
	LD R2,Matrix_Address		;POINTS TO BEGININNIG OF OUTER MATRIX
	LD R0,TwentyThreeValue		;IF WE ADD THIS TO R2 IT WILL POINT TO THE START OF INNER MATRIX(Maze)
	ADD R2 R0 R2				;POINT TO INNER MATRIX
		
	ST R2,INNER_MATRIX_ADRESS	;FINALLY INNER MATRIX ADDRESS :)!
	ADD R2 R2 R1			
	ADD R2 R2 #-1				;POINT TO (0,N-1)
	LD R0,GO_TO_LAST_CELL	
	ADD R2 R2 R0				;ADDS 22 * N-1 TO R2 AND NOW WE ARE AT LAST MEMBER IN INNER MATRIX (N-1,N-1)
	ST R2,LAST_MEMBER_ADRESS	;SAVES (N-1.N-1) OF INNER MATRIX ADRESS
	AND R0 R0 #0
	ADD R0 R0 #2
	STR R0 R2 #0				;PUT 2 IN LAST CELL IN MAZE (SYMBOLS TO 'CHEESE')

;-------------- CALL THE BACKTRACKING FUNCTION -------------
	LD R2 INNER_MATRIX_ADRESS	
	LD R1,INNER_MATRIX_SIZE

    STR R1 R6 #-2 				;LOAD N <-> SIZE
    STR R2,R6,#-1				;LOAD POINTER TO MATRIX
    ADD R6,R6,#-2
    JSR SOLVE_MAZE
    ADD R6,R6,#2


HALT

STACK_ADDRESS .fill XBFFF
SIZE_t .fill 4
Matrix_Address .fill Matrix
GO_TO_LAST_CELL .fill #0
RETRY_MESS .STRINGZ "Illegal maze! Please try again:"
SUCCES_MESS .STRINGZ "The mouse is hopeful he will find his cheese."
WON .STRINGZ "Yummy! The mouse has found the cheese!"
LINE_FEED .fill #10
INNER_MATRIX_ADRESS .fill #0
TwentyThreeValue .fill #23
LAST_MEMBER_ADRESS .fill #0
INNER_MATRIX_SIZE .fill #0
GetMatrix_Mess .STRINGZ "Please enter the maze matrix:"

;*****************************************************************
SOLVE_MAZE:
    ADD R6,R6,#-6		; SAVE USED REGISTERS
	STR R1,R6,#0		
	STR R2,R6,#1
	STR R3,R6,#2
	STR R4,R6,#3
	STR R5,R6,#4 		
	STR R7,R6,#5
;-----------------
    LDR R2,R6,#7        ;LOAD THE POINTER TO MATRIX FROM STACK
    LDR R3,R6,#6        ; R3<-SIZE = N

    STR R2,R6,#-1       ;LOAD POINTER TO MAIN MATRIX STARTS FROM (0,0)
    STR R3,R6,#-2       ;LOAD N = SIZE
    ADD R6,R6, #-2
    AND R0,R0,#0        ;INIT R0<-0 BECAUSE WE WILL GET THE RETURN VALUE FROM THE FUNCTION IN THIS REGISTER
    JSR SOLVE_MAZE_UTIL
    ADD R6,R6,#2        ;FOLD STACK
    ADD R0,R0,#0        ; CHECK THE RETURN VALUE
    BRp CONTINUE        ; IF R0==1 THAT MEANS THE SOLUTIONS WAS PRINTED IN THE RECURSIVE FUNCTION
    LEA R0,FAILED       ; ELSE , PRINT TO THE USER THAT NO SOLUTION WAS FOUND!
    PUTS
    BR END_MAZE
CONTINUE:
    LD R2,USR_ASK_MORE
    ADD R2,R2,#-1		; IF THIS FLAG IS IN AND PRINT FUNCTION DOESNT OFF IT, PRINT THIS MESSAGE
    BRnp END_MAZE
    AND R0,R0,#0
    LEA R0,NO_MORE_MESS
    PUTS

;-----------------
END_MAZE:
	LDR R1,R6,#0		
	LDR R2,R6,#1
	LDR R3,R6,#2
	LDR R4,R6,#3
	LDR R5,R6,#4 		
	LDR R7,R6,#5 
	ADD R6,R6,#6			
RET
FAILED .STRINGZ "OH NO! It seems the mouse has no luck in this maze."
NO_MORE_MESS .STRINGZ "OH NO! It seems the mouse could not find another solution for this maze."
;******************************************************************
;THIS FUNCTION ASKED THE USER IF HE WANTS ANOTHER SOLUTIONS 
ANOTHER_SOLUTION:
    ADD R6,R6,#-6       ;STORE USED REGISTERS ON SATCK
	STR R1,R6,#0		
	STR R2,R6,#1  
	STR R3,R6,#2 
	STR R4,R6,#3
	STR R5,R6,#4 		
	STR R7,R6,#5


;FIRSTLY PRINT THE MESSAGE
;-------- SAVE R0---------
    ST R0,SAVE_IN_SOL

    LD R3,CAPITAL_N      ;WITH MINUS SIGN
    LD R4,SMALL_N

    LEA R0 ASK_USER_MESS
    PUTS
    AND R0,R0,#0
    GETC
    OUT

    ADD R2,R0,#0  		  ;SAVE THE ANSWER
    ADD R5,R2,R3
    BRz ANSWER_NO
    ADD R5,R2,R4
    BRz ANSWER_NO

    LD R3,CAPITAL_Y       ;WITH MINUS SIGN
    LD R4,SMALL_Y

    ADD R5,R2,R3
    BRz ANSWER_YES
    ADD R5,R2,R4
    BRz ANSWER_YES

;IF THE ANSWER IS NO,THEN JUST OFF THE FLAG AND THE BACKTRACKING FUNC WILL BREAK
ANSWER_NO:
    AND R5,R5,#0
    ST R5,FLAG
    BR BACK

;IF THE ANSWER  WAS YES THEN GO BACK TO THE FUNCTION AND CONTINUE BACKTRAKING
ANSWER_YES:
	AND R4,R4,#0
	ADD R4,R4,#1
	ST R4,USR_ASK_MORE
	

   	LD R0,SAVE_IN_SOL
;------ FREE WITH R0--------


BACK:
	ST R0,SAVE_IN_SOL
	AND R0,R0,#0
	ADD R0,R0,#10
	OUT
	LD R0,SAVE_IN_SOL

	LDR R2 R6 #7 
	LDR R1 R6 #6

	LDR R1,R6,#0		
	LDR R2,R6,#1
	LDR R3,R6,#2
	LDR R4,R6,#3
	LDR R5,R6,#4 		
	LDR R7,R6,#5 
	ADD R6,R6,#6
RET
SMALL_N .fill #-110
CAPITAL_N .fill #-78
SMALL_Y .fill #-121
CAPITAL_Y .fill #-89
ASK_USER_MESS .STRINGZ "Would you like to see another solution? "
USR_ASK_MORE .fill #0
SAVE_IN_SOL .fill #0

;*****************************************************************
; THIS IS THE BACKTRACKING FUNCTION THAT SOLVES "RAT IN MAZE" PROBLEM

SOLVE_MAZE_UTIL:
    ADD R6,R6,#-6       ;STORE USED REGISTERS ON SATCK
	STR R1,R6,#0		
	STR R2,R6,#1  
	STR R3,R6,#2 
	STR R4,R6,#3
	STR R5,R6,#4 		
	STR R7,R6,#5
;-----------------
    LDR R2,R6,#7        ;LOAD THE POINTER TO MAIN MATRIX - CURRENT CELL
    LDR R1,R6,#6        ;LOAD THE SIZE
 

    AND R3,R3,#0        ;INIT THESE REGISTERS TO USE THEM LATER
    AND R4,R4,#0 
    AND R5,R5,#0

    LD R3,FLAG          ;CHECK THE GLOBAL FLAG
    ADD R3,R3,#0        ; IF FLAG == 1 --> CONTINUE IN FUNCTION, ELSE STOP AND RETURN
    BRz  DONE 			; IF WE GET HERE, IT SEEMS THAT THE USER SAYED "NO" TO "ANOTHER SOLUTIONS"
	AND R3,R3,#0
; ------------- CHECK IF WE FIND THE GOAL ---------------- ;

    AND R3,R3,#0        ; INITIALIZE R3<-0 
    LDR R3,R2,#0        ; R3<- MEM[R2+0]   =  MATRIX[CURRENT_POSITION]
   	ADD R3 R3 #-2		;IF WE REACH THE CHEESE THAT MEANS WE HAVE FOUND SOLUTION, SO HANDLE THAT CASE...
	BRz CHEESE_FOUND


	LD R4 UP_DOWN 		
	LD R5 STAR_SYM
	
; ------------- CHECK THE BEST DIRECTION TO CONTINUE WITH  ---------------- ;

	LDR R2,R6,#7        ;POINTER
	LDR R1,R6,#6        ;SIZE

; CHECK IF IT'S LEGAL TO GO DOWN
	ADD R3 R2 #0        ;HOLDS CURRENT VALUE IN MATRIX
	ADD R3 R3 R4        ;CHECK IF THE DOWN CELL CONTAINS 2 <-> *(MATRIX+22)=2
	LDR R3 R3 #0 		;GET THE VALUE IN IN THIS CELL/ADDRESS
	ADD R3 R3 #-2
	BRz GO_DOWN			
	ADD R3 R2 #0
	ADD R3 R3 R4
	LDR R3 R3 #0        ;CHECK IF THE DOWN CELL CONTAINS 1 <-> *(MATRIX+22)=1
	ADD R3 R3 #-1
	BRz GO_DOWN


; CHECK IF IT'S LEGAL TO GO RIGHT
RETURN_1:
;RELOAD THE PARAMETERS OF THE FUNCTION
	LDR R2,R6,#7
	LDR R1,R6,#6        

	LDR R3 R2 #1
	ADD R3 R3 #-2		;IF TO RIGHT IS 2(THE CHEESE)
	BRz GO_RIGHT
	LDR R3 R2 #1
	ADD R3 R3 #-1		;IF TO RIGHT IS 1 WHICH IS LEGAL TO GO TO
	BRz GO_RIGHT
	
; CHECK IF IT'S LEGAL TO GO UP
RETURN_2:
	LDR R2,R6,#7
	LDR R1,R6,#6 

	NOT R4 R4
	ADD R4 R4 #1

	ADD R3 R2 #0
	ADD R3 R3 R4		;ADDS -22 WHICH WILL TAKE AS UP FROM WHERE WE ARE 
	LDR R3 R3 #0
	ADD R3 R3 #-1		;CHEKS IF UP IS 1 
	BRz GO_UP


; CHECK IF IT'S LEGAL TO GO LEFT
RETURN_3:
 	LDR R2,R6,#7
	LDR R1,R6,#6 

	LDR R3 R2 #-1
	ADD R3 R3 #-1		;IF TO LEFT IS 1
	BRz GO_LEFT

; SEEMS THAT THERE ARE NO REMAINING DIRECTIONS
RETURN_4:
	BR DONE			        
	

GO_RIGHT:					;WE REACH THIS LINE IF IT'S LEGAL TO GO RIGHT, SO WE WILL UPDATE VARIABLES..
	STR R5 R2 #0			;SIGN WE HAVE BEEN HERE - PUT *
	ADD R2 R2 #1			;UPDATES R2 TO POINT ONE PLACE TO THE RIGHT
	;LDR R1,R6,#6           ;R1 <- SIZE
	STR R2 R6 #-1			;LOAD &MATRIX
	STR R1,R6,#-2           ;LOAD SIZE
	ADD R6 R6 #-2
	JSR SOLVE_MAZE_UTIL
	ADD R6 R6 #2			;CLOSES SCOPE 

	LDR R2 R6 #7			;LOADS RESTORES THE CURRENT PLACE WE WAS IN 
   	 ST R3,TEMP3_SAVE
    LD R3,ONE
    STR R3,R2,#0        	; UNSIGHNED THIS PLACE TO TRY OTHER POSSIBLE SOLUTIONS
    LD R3,TEMP3_SAVE

	BR RETURN_2				; BACK TO TRY REMAINING DIRECTIONS

GO_LEFT:					;WE REACH THIS LINE IF IT'S LEGAL TO GO LEFT, SO WE WILL UPDATE VARIABLES..
	STR R5 R2 #0			;PUT * 
	ADD R2 R2 #-1			;UPDATE R2 TO POINT ONE PLACE TO THE LEFT
	STR R2 R6 #-1			;LOADS PARAMTER FOR RECURSIVE CALL
	STR R1,R6,#-2
	ADD R6 R6 #-2
	JSR SOLVE_MAZE_UTIL
	ADD R6 R6 #2			;CLOSES SCOPE 

	LDR R2 R6 #7			;LOADS RESTORES THE CURRENT PLACE WE WAS IN 
    ST R3,TEMP3_SAVE
    LD R3,ONE
    STR R3,R2,#0        	; UNSIGHNED THIS PLACE TO TRY OTHER POSSIBLE SOLUTIONS
    LD R3,TEMP3_SAVE
	BR RETURN_4				;TRY REMAINING DIRECTIONS

GO_DOWN:					;WE REACH THIS LINE IF IT'S LEGAL TO GO DOWN, SO WE WILL UPDATE VARIABLES..
	STR R5 R2 #0			;TO KNOW WE BEEN HERE WE PUT *
	LD R4 UP_DOWN 
	ADD R2 R2 R4			;ADDS 22 SO WE NOW POINT ONE PLACE DOWN
	STR R2 R6 #-1			;LOADS PARAMTER FOR RECURSIVE CALL
	STR R1,R6,#-2
	ADD R6 R6 #-2
	JSR SOLVE_MAZE_UTIL
	ADD R6 R6 #2			;CLOSES SCOPE FROM LATESET RECUSRIVE CALL
	LDR R2 R6 #7			;LOADS RESTORES THE CURRENT PLACE WE ON AFTER RETURING FROM GOING DOWN
    ST R3,TEMP3_SAVE
    LD R3,ONE
    STR R3,R2,#0      	    ; UNSIGHNED THIS PLACE TO TRY OTHER POSSIBLE SOLUTIONS
    LD R3,TEMP3_SAVE
	BR RETURN_1				;TRY REMAINING DIRECTIONS

GO_UP:						;WE REACH THIS LINE IF IT'S LEGAL TO GO UP, SO WE WILL UPDATE VARIABLES..
	STR R5 R2 #0		;TO KNOW WE BEEN HERE 
	LD R4 UP_DOWN 
	NOT R4 R4
	ADD R4 R4 #1
	ADD R2 R2 R4			;ADDS -22 SO WE NOW POINT ONE PLACE UP
	STR R2 R6 #-1			;LOADS PARAMTER FOR RECURSIVE CALL
	STR R1,R6,#-2
	ADD R6 R6 #-2	
	JSR SOLVE_MAZE_UTIL
	ADD R6 R6 #2			;CLOSES SCOPE FROM LATESET RECUSRIVE CALL
	LDR R2 R6 #7			;LOADS RESTORES THE CURRENT PLACE WE ON AFTER RETURING FROM GOING UP
    ST R3,TEMP3_SAVE
    LD R3,ONE
    STR R3,R2,#0        	; UNSIGHNED THIS PLACE TO TRY OTHER POSSIBLE SOLUTIONS
    LD R3,TEMP3_SAVE
	BR RETURN_3				;TRY REMAINING DIRECTIONS
	
CHEESE_FOUND:				;WE RECHED THE CHEESE	
    ADD R0,R0,#1		    ;FLAG ON : R0<-1 , RETURNING VALUE TO THE CALLER FUNCTION 
	LD R5 STAR_SYM
	STR R5 R2 #0		    ;PUTS *

;SINCE WE HAD FOUND A SOLUTION NOW, PRINT IT!

    STR R2 R6 #-1			;LOADS PARAMTER FOR PRINTMATRIX FUNC (POINTER TO MATRIX)
	STR R1 R6 #-2			;HOLDS N =SIZE
	ADD R6 R6 #-2
	JSR printMatrix	        ; PRINT THE SOLUTION
	ADD R6 R6 #2			;FOLD STACK

	LDR R2 R6 #7		    ;LOADS RESTORES THE CURRENT PLACE WE ON AFTER RETURING FROM GOING UP
   	ST R3,TEMP3_SAVE
   	LD R3,TWO
   	STR R3,R2,#0            ;UNSIGHNED THIS PLACE TO TRY OTHER POSSIBLE SOLUTIONS
   	LD R3,TEMP3_SAVE
	ST R0,TEMP_SAVE
	LD R0,ENTER
	OUT

	AND R0,R0,#0
	LD R0,TEMP_SAVE
	JSR ANOTHER_SOLUTION	;WE HAVE TO ASK USER IF HE WANTS MORE OTHER SOLUTIONS;IF YES,
							;WE CAN CONTINUE IN THE BACKTRACKING FUNCTION,ELSE WE BREAK 
DONE:
;-----------------			;RESTORE SAVED REGISTERS
	LDR R1,R6,#0		
	LDR R2,R6,#1
	LDR R3,R6,#2
	LDR R4,R6,#3
	LDR R5,R6,#4 		
	LDR R7,R6,#5 
	ADD R6,R6,#6			
RET
FLAG .fill #1 				;THIS FLAG IS 'ON' UNTIL THE USER SAYS HE DOESNT WANT ANOTHER SOLUTION
STAR_SYM .Fill #42
UP_DOWN .fill #22
Minus_Zero_Ascii .fill #-48
ZERO_ASCCI .fill #48
Minus_One_Ascii  .fill #-49
TEMP_SAVE .fill #0
TEMP2_SAVE .fill #0
TEMP3_SAVE .fill #0
ONE .fill #1
TWO .fill #2
;******************************************************************
;THIS FUNCTION PRINTS THE SOLUTION MATRIX (INNER MATRIX ONLY!)

printMatrix:
   	ADD R6,R6,#-6       		;STORE USED REGISTERS ON SATCK
	STR R1,R6,#0		
	STR R2,R6,#1  
	STR R3,R6,#2 
	STR R4,R6,#3
	STR R5,R6,#4 		
	STR R7,R6,#5
	
	AND R1,R1,#0
	ST R1,USR_ASK_MORE      	;TURN OFF THE FLAG

	AND R1,R1,#0
	AND R2,R2,#0
	LDR R1 R6 #6				; SIZE = N
	LD R2,TwentyThree

;THE POINTER THAT THIS FUNCTION HAVE IS A POINTER TO THE LAST CELL IN THE MATRIX,
;SO FIRSTLY WE HAVE TO GO BACK (DECREMENT THE POINTER) AND POINT TO THE FIRST CELL IN MATRIX

	ST R0,SAVE_0
	AND R0,R0,#0
	STR R1 R6 #-2				; HOLD N		
	STR R2 R6 #-1				;LOADS PARAMTERS FOR MUL FUNCTION TO DO R1 * R2 
	ADD R6 R6 #-2
	JSR Mul						;R0 HOLDS 23 * N
	ADD R6 R6 #2

	NOT R0,R0
	ADD R0,R0,#1				; R0<-(-23N)
	ADD R0,R0,#15
	ADD R0,R0,#7				;R0<- (-23N) + 22
	LDR R2 R6 #7				;POINTER TO LAST CELL
	ADD R2,R2,R0				;R2<- R2 + (-23N) +22 <== THIS WILL TAKE US TO THE FIRST CELL IN INNER MATRIX
	LD R0,SAVE_0


	LDR R1 R6 #6				;R1<- SIZE , LOADED FROM STACK
	
    ST R0,SAVE_0				;PRINT THIS MESSAGE BEFORE THE MATRIX
   	LEA R0,Yummy_MESS
   	PUTS
	AND R0,R0,#0
	LD R0,ENTER
	OUT
   	LD R0,SAVE_0

	ST R1 SIZE

	ADD R7 R1 #0				;HOLDS N COUNTER FOR LINES
	ADD R5 R1 #0				;HOLDS N COUNTER FOR COLUMNS

	
While:
	AND R5 R5 R5
	BRnz Next_Line
	LDR R3 R2 #0				;LOADS THE VALUE IN MATRIX
	add r3,r3,#1
	BRz INCREMENT
	LDR R3 R2 #0
	LD R4 STAR_ASCII
	ADD R4 R4 R3				;IF *
	BRz prt_star
	LD R4 PLUS_ZERO				;+48
	ADD R3 R3 R4				;0 OR 1 ASCII VALUE
	ADD R0 R3 #0		
	OUT
	ADD R5 R5 #-1
	LD R0 SPACE
	OUT		
INCREMENT: 
    ADD R2 R2 #1
	BR While

prt_star:
	ADD R0 R3 #0
	OUT
	ADD R5 R5 #-1
	ADD R2 R2 #1
	LD R0 SPACE
	OUT
	BR While

Next_Line:
	ADD R1 R1 #-1
	BRz FINSH
	LD R4 PLUS_FULL_MAT_LINE
	LD R7 SIZE
	NOT R7 R7
	ADD R7 R7 #1
	ADD R4 R4 R7				;22-N
	ADD R2 R2 R4				;NEW LINE
	LD R5 SIZE
	AND R0 R0 #0
	ADD R0 R0 #10
	OUT
	BR While

FINSH:
	LDR R2 R6 #7 
	LDR R1 R6 #6
	
	LDR R1,R6,#0		
	LDR R2,R6,#1
	LDR R3,R6,#2
	LDR R4,R6,#3
	LDR R5,R6,#4 		
	LDR R7,R6,#5 
	ADD R6,R6,#6
RET

STAR_ASCII .fill #-42
PLUS_ZERO  .fill #48
SIZE .fill #0
SPACE .fill #32
ENTER .fill #10
PLUS_FULL_MAT_LINE .fill #22
Yummy_MESS .STRINGZ "Yummy! The mouse has found the cheese!"
SAVE_0 .fill #0
;**************************************************************************************
;******************************** HELPER FUNCTIONS ************************************
;**************************************************************************************

; THIS FUNTION GETS THE SIZE OF MATRIX FROM THE USER
GetNum:
	ADD R6 R6 #-5		
	STR R1 R6 #0
	STR R2 R6 #1				;SAVE REGISTER
	STR R3 R6 #2
	STR R4 R6 #3
	STR R7 R6 #4
	
	LEA R0 SIZE_MESSAGE
	PUTS
	AND R3 R3 #0
	GETC						;TAKES FIRST DIGIT
	OUT
	LD R4 MinusEnterAsc
	ADD R4 R0 R4
	BRz Enter					
	LD R4 MinusZeroAsc
	ADD R0 R4 R0				;FROM ASCII TO INTEGER
	ADD R3 R3 R0				;R1 HOLDS FIRST DIGIT
	GETC						;TAKES SECOND INPUT
	OUT
	LD R4 MinusEnterAsc
	ADD R4 R0 R4		
	BRz Enter		
	LD R4 MinusZeroAsc
	ADD R0 R4 R0				;FROM ASCII TO INTEGER NUMBER FROM TWO DIGITS	
	LD R1 Ten
	ST R0 SEC_DIGIT		
	ADD R2 R3 #0				;R2 HOLDS FIRST DIGIT  TO USE FOR MUL


	STR R1 R6 #-2				;HOLDS 10 AS PARAMTER FOR MUL
	STR R2 R6 #-1				;HOLDS FIRST DIGIT AS PARAMTER FOR MUL
	ADD R6 R6 #-2
	JSR Mul
	ADD R6 R6 #2				;CLOSE SCOPE 
	LD R3 SEC_DIGIT
	ADD R3 R3 R0				;SECOND DIGIT + 10*FIRST DIGIT
	GETC						;WE TOOK NUMBER FROM 2 DIGITS NOW WE FINISHED
	OUT 						;FOR ENTER IF 2 DIGIT NUMEBR
	
Enter:
	ADD R0 R3 #0				;HOLDS NUMBER 
	
Finish_GetNum:
	LDR R1 R6 #0
	LDR R2 R6 #1
	LDR R3 R6 #2		
	LDR R4 R6 #3
	LDR R7 R6 #4
	ADD R6 R6 #5		;POP

RET
SEC_DIGIT .fill #10
Ten .fill #10
MinusZeroAsc .fill #-48
MinusEnterAsc .fill #-10
SIZE_MESSAGE .STRINGZ "Please enter a number between 2 to 20: "

;******************************************************************************
;THESE VARIABLES USED IN MORE THAN ONE FUNCTION SO WE PUT THEM HERE! (CLOSE TO ALL OF THEM)
Enter_Ascii .fill #10
Minus_Enter_Ascii .fill #-10
Minus_Space_Ascii .fill #-32
Minus_Zero_Ascii_NEW .fill #-48
Minus_One_Ascii_NEW  .fill #-49
N_SIZE .fill #0
Write_Here .fill #0
TwentyThree .fill #23
TwentyTwo .fill #22
;******************************************************************
GetMatrix:
	
	ADD R6 R6 #-4		
	STR R3 R6 #0
	STR R4 R6 #1	
	STR R5 R6 #2
	STR R7 R6 #3
	
	LDR R2 R6 #4			;LOADS PARAMTER THAT HOLDS POINTER TO OUTER MATRIX 
	LDR R1 R6 #5			;LOADS PARAMETRS THAT HOLD N SIZE
	
						
	AND R5 R5 #0			;R5 FLAG FOR LEGAL OR NOT R0 WILL TAKE IT VALUE
	ST R1 N_SIZE		
	LD R3 TwentyThree
	ADD R2 R2 R3 			;NOW POINTS TO INNER MATRIX
	ST R2 Write_Here

RES:	
	GETC					;TAKES FIRST DIGIT IN THE LINE
	OUT
	LD R4 Minus_Enter_Ascii
	ADD R4 R4 R0	
	BRz ent_new_line		;LINE FEED WAS ENTERED 
	LD R4 Minus_Space_Ascii
	ADD R4 R4 R0		
	BRz RES				
	AND R5 R5 R5			;FLAG FOR ILLEGAL INPUT SO JUST KEEP TAKING 
	BRp RES
	LD R4 Minus_One_Ascii_NEW
	ADD R4 R4 R0
	BRz LEGAL_Entered		;IF 1 WAS ENTERED
	LD R4 Minus_Zero_Ascii_NEW
	ADD R4 R4 R0
	BRz LEGAL_Entered		;IF 0 WAS ENTERED
	ADD R5 R5 #1			;ILLEGAL INPUT BECAUSE NOT 1 OR 0
	BR RES

LEGAL_Entered:		
	LD R4 Minus_Zero_Ascii_NEW
	ADD R0 R0 R4			;FROM ASCII TO INETEGER
	STR R0 R2 #0			;WRITES IN MATRIX
	ADD R2 R2 #1
	GETC					;AFTEER TAKING LEGAL DIGIT IF SOMETHING OTHER THAN ENTER OR SPACE IS TAKING THEN ITS ILLEGAL
	OUT						;IF NOT SPACE OR ENTER THEN ILLEGAL FLAG UP (R5) 
	LD R4 Minus_Space_Ascii
	ADD R4 R4 R0
	BRz RES					;SPACE ENTERED AFTER LEGAL INPUT
	LD R4 Minus_Enter_Ascii
	ADD R4 R4 R0
	BRz ent_new_line 		;LINE FEED WAS ENTERED
	ADD R5 R5 #1			;FLAG UP
	BR RES

ent_new_line:
	ADD R1 R1 #-1			;N LINES TO FILL AFTER EVERY LINE FEED WE DECREASE BY ONE
	BRz FINISHED_FILL
	LD R4 TwentyTwo
	LD R0 N_SIZE
	NOT R0 R0
	ADD R0 R0 #1
	ADD R4 R4 R0			;22-N 
	ADD R2 R2 R4			;NEW LINE FOR INNER MATRIX
	BR RES

CHECK_IF_ONE:
	ADD R2 R2 #-1
	LDR R2 R2 #0
	BRp CHECK_00			;CHECK N-1 N-1 PLACE IS 1
	ADD R5 R5 #1
	BR CLOSE
CHECK_00:
	LD R2 Write_Here		;HOLDS 0,0 PLACE TO CHECK IF 1
	LDR R2 R2 #0
	BRp CLOSE
	ADD R5 R5 #1
	BR CLOSE

FINISHED_FILL:
							;R2 POINTS TO N-1 N-1
	AND R5 R5 R5
	BRz CHECK_IF_ONE		;ENTERED 0,1 WE CHECK 0,0 AND N-1 N-1 
CLOSE:
	ADD R0 R5 #0			;TO SEE FLAG IF WE ENTERED LEGAL MATRIX R0 HOLDS RETURN VALUE
	LDR R2 R6 #4			;HOLD MATRIX ADDRESS
	LDR R1 R6 #5			;HOLD N SIZE
	
	LDR R3 R6 #0
	LDR R4 R6 #1			;LOADS REGGIESTR
	LDR R5 R6 #2
	LDR R7 R6 #3

	ADD R6 R6 #4			;POP
RET
;******************************************************************
;MUL(R1,R2)
Mul:
	ADD R6 R6 #-3
	STR R3 R6 #0
	STR R4 R6 #1	
	STR R7 R6 #2

	LDR R1 R6 #3
	LDR R2 R6 #4			;LOADS PARAMETRS 

	AND R0,R0,#0			;WILL HOLDS THE ANSWER
	ADD R3,R2,#0 			;R3<-R2			;first DIGIT
	ADD R4,R1,#0 			;R4<-R1			;HOLDS 10
	
WHILE1: 					;R0(R3) POSTIVE SO -1 
	AND R3,R3,R3 
	BRz END_LOOP
	ADD R0,R0,R4			;DOES R1 + R1 +....R1 , R2 TIMES
	ADD R3,R3,#-1
	BR WHILE1


END_LOOP:
	LDR R3 R6 #0
	LDR R4 R6 #1		
	LDR R7 R6 #2
	ADD R6 R6 #3			;POP
	
RET
Matrix .BLKW #484 #-1 	;MATRIX SIZE 22X22 

;EXPLAINATION OF THE SOLUTION:
;-----------------------------
;firstly, we declared a matrix called "OUTER_MATRIX" with size 22*22, because wa wants to cover the
;size of 20*20 elements (the max N of size 20). In this matrix we will hold the N*N maze(INNER_MATRIX).
;we do so beacuse we wants to fill the surrounding cells with -1 
;and that will helps us with navigation in the maze (we will not get illegal position)
; we found that this is more efficient instead of navigation with [i][j] indexes and using 'Mull' function
; in each time we want to get value from the matrix.
;so in each function we have done some additional calculation to jumb from the first cell
;in the outer matrix to the first cell in inner matrix.


.END